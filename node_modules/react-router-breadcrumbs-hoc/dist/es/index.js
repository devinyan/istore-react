import { createElement } from 'react';
import { matchPath, withRouter } from 'react-router';

var decamelize = function (str, sep) {
	if (typeof str !== 'string') {
		throw new TypeError('Expected a string');
	}

	sep = typeof sep === 'undefined' ? '_' : sep;

	return str
		.replace(/([a-z\d])([A-Z])/g, '$1' + sep + '$2')
		.replace(/([A-Z]+)([A-Z][a-z\d]+)/g, '$1' + sep + '$2')
		.toLowerCase();
};

var humanizeString = function (str) {
	if (typeof str !== 'string') {
		throw new TypeError('Expected a string');
	}

	str = decamelize(str);
	str = str.toLowerCase().replace(/[_-]+/g, ' ').replace(/\s{2,}/g, ' ').trim();
	str = str.charAt(0).toUpperCase() + str.slice(1);

	return str;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

var DEFAULT_MATCH_OPTIONS = { exact: true };
var NO_BREADCRUMB = 'NO_BREADCRUMB';

// renders and returns the breadcrumb complete with `match`, `location`, and `key` props
var render = function render(_ref) {
  var breadcrumb = _ref.breadcrumb,
      match = _ref.match,
      location = _ref.location;

  var componentProps = { match: match, location: location, key: match.path };
  if (typeof breadcrumb === 'function') {
    return createElement(breadcrumb, componentProps);
  }
  return createElement('span', componentProps, breadcrumb);
};

// small helper method to get a default `humanize-string` breadcrumb if the
// user hasn't provided one
var getDefaultBreadcrumb = function getDefaultBreadcrumb(_ref2) {
  var pathSection = _ref2.pathSection,
      currentSection = _ref2.currentSection,
      location = _ref2.location;

  var match = matchPath(pathSection, _extends({}, DEFAULT_MATCH_OPTIONS, { path: pathSection }));

  return render({
    breadcrumb: humanizeString(currentSection),
    match: match,
    location: location
  });
};

// loops through the route array (if provided) and returns either
// a user-provided breadcrumb OR a sensible default via `humanize-string`
var getBreadcrumb = function getBreadcrumb(_ref3) {
  var currentSection = _ref3.currentSection,
      disableDefaults = _ref3.disableDefaults,
      excludePaths = _ref3.excludePaths,
      location = _ref3.location,
      pathSection = _ref3.pathSection,
      routes = _ref3.routes;

  var breadcrumb = void 0;

  // check the optional `exludePaths` option in `options` to see if the
  // current path should not include a breadcrumb
  if (excludePaths && excludePaths.includes(pathSection)) {
    return NO_BREADCRUMB;
  }

  // loop through the route array and see if the user has provided a custom breadcrumb
  routes.some(function (_ref4) {
    var userProvidedBreadcrumb = _ref4.breadcrumb,
        matchOptions = _ref4.matchOptions,
        path = _ref4.path;

    if (!path) {
      throw new Error('withBreadcrumbs: `path` must be provided in every route object');
    }

    var match = matchPath(pathSection, _extends({}, matchOptions || DEFAULT_MATCH_OPTIONS, { path: path }));

    // if user passed breadcrumb: null OR custom match options to suppress a breadcrumb
    // we need to know NOT to add it to the matches array
    // see: `if (breadcrumb !== NO_BREADCRUMB)` below
    if (match && userProvidedBreadcrumb === null || !match && matchOptions) {
      breadcrumb = NO_BREADCRUMB;
      return true;
    }

    if (match) {
      // this covers the case where a user may be extending their react-router route
      // config with breadcrumbs, but also does not want default breadcrumbs to be
      // automatically generated (opt-in)
      if (!userProvidedBreadcrumb && disableDefaults) {
        breadcrumb = NO_BREADCRUMB;
        return true;
      }

      breadcrumb = render({
        // although we have a match, the user may be passing their react-router config object
        // which we support. The route config object may not have a `breadcrumb` param specified.
        // If this is the case, we should provide a default via `humanizeString`
        breadcrumb: userProvidedBreadcrumb || humanizeString(currentSection),
        match: match,
        location: location
      });
      return true;
    }
    return false;
  });

  if (breadcrumb) {
    // user provided a breadcrumb prop, or we generated one via humanizeString above ~L75
    return breadcrumb;
  } else if (disableDefaults) {
    // if there was no breadcrumb provided and user has disableDefaults turned on
    return NO_BREADCRUMB;
  }

  // if the above conditionals don't fire, generate a default breadcrumb based on the path
  return getDefaultBreadcrumb({
    pathSection: pathSection,
    // include a "Home" breadcrumb by default (can be overrode or disabled in config)
    currentSection: pathSection === '/' ? 'Home' : currentSection,
    location: location
  });
};

var getBreadcrumbs = function getBreadcrumbs(_ref5) {
  var routes = _ref5.routes,
      location = _ref5.location,
      _ref5$options = _ref5.options,
      options = _ref5$options === undefined ? {} : _ref5$options;

  var matches = [];
  var pathname = location.pathname;


  pathname.split('?')[0]
  // remove trailing slash "/" from pathname
  .replace(/\/$/, '')
  // split pathname into sections
  .split('/')
  // reduce over the sections and find matches from `routes` prop
  .reduce(function (previousSection, currentSection) {
    // combine the last route section with the currentSection
    // ex `pathname = /1/2/3 results in match checks for
    // `/1`, `/1/2`, `/1/2/3`
    var pathSection = !currentSection ? '/' : previousSection + '/' + currentSection;

    var breadcrumb = getBreadcrumb(_extends({
      currentSection: currentSection,
      location: location,
      pathSection: pathSection,
      routes: routes
    }, options));

    // add the breadcrumb to the matches array
    // unless the user has explicitly passed { path: x, breadcrumb: null } to disable
    if (breadcrumb !== NO_BREADCRUMB) {
      matches.push(breadcrumb);
    }

    return pathSection === '/' ? '' : pathSection;
  }, null);

  return matches;
};

// takes a route array and recursively flattens it IF there are
// nested routes in the config
var flattenRoutes = function flattenRoutes(routes) {
  return routes.reduce(function (arr, route) {
    if (route.routes) {
      return arr.concat([route].concat(toConsumableArray(flattenRoutes(route.routes))));
    }
    return arr.concat(route);
  }, []);
};

var withBreadcrumbs = function withBreadcrumbs() {
  var routes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var options = arguments[1];
  return function (Component) {
    return withRouter(function (props) {
      return createElement(Component, _extends({}, props, {
        breadcrumbs: getBreadcrumbs({
          routes: flattenRoutes(routes),
          location: props.location,
          options: options
        })
      }));
    });
  };
};

export default withBreadcrumbs;
export { getBreadcrumbs };
//# sourceMappingURL=index.js.map
